## Lab 1.1 — Declarative vs Imperative Highlight Toggle

In the imperative implementation of the highlight toggle, I used jQuery to manipulate the DOM step by step. The HTML page defines a button and a paragraph, and the JavaScript attaches a click handler to the button with `$('#toggleButton').on('click', ...)`. Inside that handler, I call `$('#text').toggleClass('highlight')` which directly adds or removes the CSS class on the paragraph. This style of code is typical of imperative UI: each user interaction is handled by explicitly finding a DOM node and mutating its classes. As the textbook notes in Chapter 1, this is how many older front‑end stacks worked before React: the developer is responsible for keeping the DOM in sync with changing data.

The React implementation replaces those manual DOM operations with a declarative description of UI state. In the React version, I created a `HighlightToggle` component that holds a boolean `isHighlighted` state with `useState`. Instead of directly touching the DOM, the component’s JSX returns a paragraph whose `className` depends on that state: when `isHighlighted` is true, the paragraph receives the `highlight` class; when it is false, the class is omitted. The click handler simply flips the state using `setIsHighlighted((prev) => !prev)`. React then re‑renders the component, compares the new virtual DOM tree with the previous one, and patches the real DOM with minimal changes. This matches Chapter 1’s idea of “declarative UI structures”: I describe what the UI should look like for a given state, and React takes care of updating the browser.

This difference becomes more important as “data changes over time” and UIs grow more complex. With the jQuery approach, every new requirement (for example, multiple paragraphs, nested highlight rules, or additional visual states) would require more event handlers and DOM queries, increasing the chance of bugs and inconsistent state. In the React approach, I can extend the component by adding more state variables or composing smaller components, while React’s diffing and patching logic keeps the DOM in sync. That makes the declarative React version easier to reason about, easier to test, and more scalable when building larger interfaces, which is why the textbook argues that declarative UI is better suited for modern applications.

